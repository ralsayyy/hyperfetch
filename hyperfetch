#!/bin/sh
# kill the script if something errors out
#set -e
# disable unicode
export LC_ALL=C
export LANG=C
# set the uid
[ "$UID" = "" ] && export UID=$(id -u)
export OSTYPE=$(uname)
# where to go to for the ascii art
PREFIX=${PREFIX:-.}

module_output() {
  echo "$1" > "$TEMP_PREFIX/$UID/hyperfetch/$2"
}

gpu_info() {
  case $OSTYPE in 
    Linux) gpu_cmd=$(lspci | grep "VGA")
  case $gpu_cmd in 
    *"NVIDIA"*) 
      IFS=\[
      set -- $gpu_cmd
      gpu="$2"
      IFS=\]
      set -- $gpu
      gpu="NVIDIA $1"
      IFS=" ";;
    *)
      IFS=:
      set -- $gpu_cmd
      gpu=$2
      IFS=" "
  esac;;
  Darwin) [ -e "$TEMP_PREFIX/$UID/hyperfetch/gpu" ] && {
    read -r gpu < "$TEMP_PREFIX/$UID/hyperfetch/gpu"
  } || {
    gpu=$(system_profiler SPDisplaysDataType | grep "Chipset Model:")
    IFS=":"
    set -- $gpu
    gpu=$2
    IFS=""
  };;
  esac
  module_output "$gpu" "gpu"
}

logo() {
  [ -e "${PREFIX}/share/hyperfetch/distro/ascii-${ascii_distro}" ] && printf "${prefix_format}" && cat "${PREFIX}/share/hyperfetch/distro/ascii-${ascii_distro}"
}

model_info() {
  case $OSTYPE in 
    Linux) model="$(cat /sys/devices/virtual/dmi/id/product_name)";;
    Darwin) model="$(sysctl -n hw.model)"
  esac
  module_output "$model" "model"
}

mem_fancy_info() {
  case $OSTYPE in
    Linux) free_mem=$(awk '/MemAvailable/ { printf "%.0f \n", $2 }' /proc/meminfo)
           total_mem=$(awk '/MemTotal/ { printf "%.0f \n", $2 }' /proc/meminfo);;
    Darwin) free_mem=$(( $(vm_stat | awk '/Pages free:/ { printf "%.0f \n", $3}') * 4096 ))
            total_mem=$(sysctl -n hw.memsize);;
  esac
  mem_percent=$(( ($total_mem - $free_mem) / ($total_mem / 100) ))
  elapsed=$(($mem_percent*15/100))
  i=0
  while [ $i != ${elapsed} ]; do
    prog="${prog} ●"
    i=$(( $i + 1 ))
  done
  i=0
  while [ $i != $(( 15 - elapsed )) ]; do
    total="${total} ○"
    i=$(( $i + 1 ))
  done
  module_output "(${prog}${total} )" "mem_fancy"
}

get_ascii_xy() {
  # ascii width is (width of ascii art + 2)
  case "$1" in 
    "arch") export ascii_width=34 ascii_height=15;;
    "gentoo") export ascii_width=37 ascii_height=17;;
    "bedrock") export ascii_width=40 ascii_height=17;;
    *) export ascii_width=0 ascii_height=0;;
  esac
}

title_info() {
  module_output "$USER\033[m@${prefix_format}${HOSTNAME:-$(hostname)}" "title"
}

term_info() {
  case $OSTYPE in 
  Linux)  read parent_stat < /proc/$PPID/stat
          set -- $parent_stat
          terminal=$(cat /proc/$4/comm);;
  Darwin) terminal=$TERM_PROGRAM;;
  esac
  module_output "$terminal" "term"
}

cpu_info() {
  case $OSTYPE in 
    Linux)  cpu=$(awk -F ":" '/model name/ {printf "%s\n", $2}' /proc/cpuinfo | head -n 1);;
    Darwin) cpu=" $(sysctl -n machdep.cpu.brand_string)";;
  esac 
  module_output "${cpu}" "cpu"
}

wm_info() {
  case $OSTYPE in 
    Linux) wm=$(wmctrl -m | awk -F ":" '/Name: / {printf "%s\n", $2}');;
    Darwin) wm=" quartz";;
  esac
  module_output "$wm" "wm"
}

memory_info() {
  case $OSTYPE in
    Linux) free_mem=$(awk '/MemAvailable/ { printf "%.0f \n", $2/1024 }' /proc/meminfo)
           total_mem=$(awk '/MemTotal/ { printf "%.0f \n", $2/1024 }' /proc/meminfo);;
    Darwin) 
          total_mem=$(( $(sysctl -n hw.memsize) / 1024 / 1024 )) 
          free_mem=$(( $total_mem - $(vm_stat | awk '/Pages free:/ { printf "%.0f \n", $3}') * 4096 / 1024 / 1024)); 
  esac
  module_output "$(( $total_mem - $free_mem ))M / ${total_mem}M" "memory"
}

shell_info() {
  module_output "$SHELL" "shell"
}

uptime_info() {
  case $OSTYPE in
  Linux)read uptime < /proc/uptime
        IFS=.
        set -- $uptime
        #the amount of secounds the system is up
        uptime_first=$1
        IFS=" "
        hours=$((uptime_first / 3600));;
  Darwin)
    last_reboot=$(sysctl -n kern.boottime)
    IFS="="
    set -- $last_reboot
    last_rebooot=$2
    IFS=,
    set -- $last_reboot
    last_reboot=$1
    IFS=" "
    set -- $last_reboot
    uptime_first=$(( $(date +%s) - $4 ))
    hours=" $((uptime_first / 3600))";;
  esac 
  minutes=$((uptime_first % 3600 / 60))
  [ $hours = 0 ] || uptime_hours=" $hours hours,"
  module_output "${uptime_hours} $minutes minutes" "uptime"
}

kernel_info() {
  kernel_release=$(uname -r)
  case $OSTYPE in
    Linux) kernel=$kernel_release;;
    Darwin) kernel="Darwin $kernel_release";;
  esac
  module_output "$kernel" "kernel"
}

distro_info() {
  module_output "$distro" "distro"
}

has() {
  command -v $1 >/dev/null
  return $?
}

packages_info() {
  {
    has qlist &> /dev/null && {
      qlist -IC | wc -l | tr -d "\n"; echo -n " (emerge) "
    } &
    has pacman-key &> /dev/null && {
      pacman -Q | wc -l | tr -d "\n"; echo -n " (pacman) "
    } &
    has brew &> /dev/null && {
      ls -1 /usr/local/Cellar/ | wc -l; echo -n " (brew)"
    } &
    wait
  } > $TEMP_PREFIX/$UID/hyperfetch/packages
}

main() {
  case $OSTYPE in 
    Linux) TEMP_PREFIX=/run/user;;
    Darwin) TEMP_PREFIX=/tmp;;
  esac
  mkdir -p $TEMP_PREFIX/$UID/hyperfetch/
  reset="\033[m"
  case $OSTYPE in 
    Linux) 
     [ -e "/bedrock/strata/bedrock/etc/os-release" ] && . /bedrock/etc/os-release || . /etc/os-release
      export distro=$PRETTY_NAME distro_id=$ID;;
    Darwin)
      export distro="macOS $(sysctl -n kern.osproductversion)"
      export distro_id=macos;;
  esac
  if [ -e "${HOME}/.config/hyperfetch/config" ];then
    . ${HOME}/.config/hyperfetch/config
  else
    infos="title distro kernel model mem_fancy uptime shell term wm cpu gpu" 
    distro_prefix="Distro${reset}: "
    kernel_prefix="Kernel${reset}: "
    uptime_prefix="Uptime${reset}:"
    shell_prefix="Shell${reset}: "
    packages_prefix="Packages${reset}: "
    memory_prefix="Memory${reset}: "
    wm_prefix="WM${reset}:"
    cpu_prefix="CPU${reset}:"
    gpu_prefix="GPU${reset}: "
    term_prefix="Terminal${reset}: "
    mem_fancy_prefix="Memory${reset}: "
    model_prefix="Device${reset}: "
    prefix_format="\033[1;38;5;5m"
    ascii_show=1
    ascii_distro="${distro_id}"
  fi
  [ "$ascii_show" = "1" ] && {
    get_ascii_xy "$ascii_distro"
    logo "${ascii_distro}" &
  } || ascii_height=0 ascii_width=0
  {
    set -f
    set +f -- ${infos}
    infos_amount="$#"
    for infos do 
      ${infos}_info &
    done
    wait
    [ "$ascii_height" != 0 ] && printf "\033[${ascii_height}A"
    for infos do
      read -r info < $TEMP_PREFIX/$UID/hyperfetch/${infos}
      prefix="$(eval printf '%s' \"\$${infos}_prefix\")"
      printf "\033[1000D\033[${ascii_width}C${prefix_format}${prefix}${info}\n"
    done
  }
  [ "$ascii_height" = 0 ] || printf "\033[$(( $ascii_height - $infos_amount ))B"
}

main $@
